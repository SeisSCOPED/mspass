<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MsPASS C++ API: mspass::algorithms::Butterworth Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script src="striped_bg.js"></script>
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"> version
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Defines the C++ API for MsPASS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mspass</b></li><li class="navelem"><b>algorithms</b></li><li class="navelem"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html">Butterworth</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmspass_1_1algorithms_1_1_butterworth-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mspass::algorithms::Butterworth Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>MsPASS implementation of <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html" title="MsPASS implementation of Butterworth filter as processing object.">Butterworth</a> filter as processing object.  
 <a href="classmspass_1_1algorithms_1_1_butterworth.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_butterworth_8h_source.html">Butterworth.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89009fa487f8a4090c5bce0c4af662cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a89009fa487f8a4090c5bce0c4af662cb">Butterworth</a> ()</td></tr>
<tr class="memdesc:a89009fa487f8a4090c5bce0c4af662cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classmspass_1_1algorithms_1_1_butterworth.html#a89009fa487f8a4090c5bce0c4af662cb">More...</a><br /></td></tr>
<tr class="separator:a89009fa487f8a4090c5bce0c4af662cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb02193564836b8f7396a9acab24a50e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#afb02193564836b8f7396a9acab24a50e">Butterworth</a> (const bool zerophase, const bool enable_lo, const bool enable_hi, const double fstoplo, const double astoplo, const double fpasslo, const double apasslo, const double fpasshi, const double apasshi, const double fstophi, const double astophi, const double sample_interval)</td></tr>
<tr class="memdesc:afb02193564836b8f7396a9acab24a50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully parameterized constructor with args similar to subfilt.  <a href="classmspass_1_1algorithms_1_1_butterworth.html#afb02193564836b8f7396a9acab24a50e">More...</a><br /></td></tr>
<tr class="separator:afb02193564836b8f7396a9acab24a50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7717b15d0d13067e819bfe3a81d806"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#afc7717b15d0d13067e819bfe3a81d806">Butterworth</a> (const <a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;md)</td></tr>
<tr class="separator:afc7717b15d0d13067e819bfe3a81d806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ccda5e0946fd375c03458a90f65c25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a85ccda5e0946fd375c03458a90f65c25">Butterworth</a> (const bool zerophase, const bool enable_lo, const bool enable_hi, const int npolelo, const double f3dblo, const int npolehi, const double f3dbhi, const double sample_interval)</td></tr>
<tr class="memdesc:a85ccda5e0946fd375c03458a90f65c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct by defining corner frequencies and number of npoles.  <a href="classmspass_1_1algorithms_1_1_butterworth.html#a85ccda5e0946fd375c03458a90f65c25">More...</a><br /></td></tr>
<tr class="separator:a85ccda5e0946fd375c03458a90f65c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c3979ede1947661bb25d118bde228c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a60c3979ede1947661bb25d118bde228c">Butterworth</a> (const <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html">Butterworth</a> &amp;parent)</td></tr>
<tr class="separator:a60c3979ede1947661bb25d118bde228c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7602075f3fe8f56e891331c98264d1a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html">Butterworth</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a7602075f3fe8f56e891331c98264d1a5">operator=</a> (const <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html">Butterworth</a> &amp;parent)</td></tr>
<tr class="separator:a7602075f3fe8f56e891331c98264d1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b54d5d5966a85092d45ebebd0b88498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">mspass::seismic::CoreTimeSeries</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a7b54d5d5966a85092d45ebebd0b88498">impulse_response</a> (const int n)</td></tr>
<tr class="memdesc:a7b54d5d5966a85092d45ebebd0b88498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the impulse response.  <a href="classmspass_1_1algorithms_1_1_butterworth.html#a7b54d5d5966a85092d45ebebd0b88498">More...</a><br /></td></tr>
<tr class="separator:a7b54d5d5966a85092d45ebebd0b88498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c696b150ed18bfb3c4060dd884bfe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#ad8c696b150ed18bfb3c4060dd884bfe3">apply</a> (<a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">mspass::seismic::CoreTimeSeries</a> &amp;d)</td></tr>
<tr class="memdesc:ad8c696b150ed18bfb3c4060dd884bfe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">pply the filter to a CoreTimeSeries object.  <a href="classmspass_1_1algorithms_1_1_butterworth.html#ad8c696b150ed18bfb3c4060dd884bfe3">More...</a><br /></td></tr>
<tr class="separator:ad8c696b150ed18bfb3c4060dd884bfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c30a560e4dce8a3bc9fe80409cee80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a10c30a560e4dce8a3bc9fe80409cee80">apply</a> (<a class="el" href="classmspass_1_1seismic_1_1_time_series.html">mspass::seismic::TimeSeries</a> &amp;d)</td></tr>
<tr class="memdesc:a10c30a560e4dce8a3bc9fe80409cee80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the filter to a CoreTimeSeries object.  <a href="classmspass_1_1algorithms_1_1_butterworth.html#a10c30a560e4dce8a3bc9fe80409cee80">More...</a><br /></td></tr>
<tr class="separator:a10c30a560e4dce8a3bc9fe80409cee80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2416893b09cf7edad320a37c521c5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a1b2416893b09cf7edad320a37c521c5a">apply</a> (std::vector&lt; double &gt; &amp;d)</td></tr>
<tr class="memdesc:a1b2416893b09cf7edad320a37c521c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a raw vector of data.  <a href="classmspass_1_1algorithms_1_1_butterworth.html#a1b2416893b09cf7edad320a37c521c5a">More...</a><br /></td></tr>
<tr class="separator:a1b2416893b09cf7edad320a37c521c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dc3f128a5305ca1b04d863ae72b73b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a76dc3f128a5305ca1b04d863ae72b73b">apply</a> (<a class="el" href="classmspass_1_1seismic_1_1_core_seismogram.html">mspass::seismic::CoreSeismogram</a> &amp;d)</td></tr>
<tr class="memdesc:a76dc3f128a5305ca1b04d863ae72b73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the filter to a CoreSeismogram object.  <a href="classmspass_1_1algorithms_1_1_butterworth.html#a76dc3f128a5305ca1b04d863ae72b73b">More...</a><br /></td></tr>
<tr class="separator:a76dc3f128a5305ca1b04d863ae72b73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8d56355bb2b23cbf7e96b0b2fa7b24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#abb8d56355bb2b23cbf7e96b0b2fa7b24">apply</a> (<a class="el" href="classmspass_1_1seismic_1_1_seismogram.html">mspass::seismic::Seismogram</a> &amp;d)</td></tr>
<tr class="memdesc:abb8d56355bb2b23cbf7e96b0b2fa7b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the filter to a CoreTimeSeries object.  <a href="classmspass_1_1algorithms_1_1_butterworth.html#abb8d56355bb2b23cbf7e96b0b2fa7b24">More...</a><br /></td></tr>
<tr class="separator:abb8d56355bb2b23cbf7e96b0b2fa7b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e766697f72f1ba38b95915805dd6d9"><td class="memItemLeft" align="right" valign="top">mspass::algorithms::deconvolution::ComplexArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a54e766697f72f1ba38b95915805dd6d9">transfer_function</a> (const int n)</td></tr>
<tr class="memdesc:a54e766697f72f1ba38b95915805dd6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the response of the filter in the frequency domain.  <a href="classmspass_1_1algorithms_1_1_butterworth.html#a54e766697f72f1ba38b95915805dd6d9">More...</a><br /></td></tr>
<tr class="separator:a54e766697f72f1ba38b95915805dd6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f20884465265de735d05946e1cea00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a94f20884465265de735d05946e1cea00">change_dt</a> (const double dtnew)</td></tr>
<tr class="memdesc:a94f20884465265de735d05946e1cea00"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the sample interval assumed for input data.  <a href="classmspass_1_1algorithms_1_1_butterworth.html#a94f20884465265de735d05946e1cea00">More...</a><br /></td></tr>
<tr class="separator:a94f20884465265de735d05946e1cea00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d5b940b443524dbe317ae6b0efb1a3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a98d5b940b443524dbe317ae6b0efb1a3">low_corner</a> () const</td></tr>
<tr class="separator:a98d5b940b443524dbe317ae6b0efb1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae23f17a07efa21effb10a9da730f33"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#acae23f17a07efa21effb10a9da730f33">high_corner</a> () const</td></tr>
<tr class="separator:acae23f17a07efa21effb10a9da730f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b528a200c2b56f9420a5f29fb706d3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a2b528a200c2b56f9420a5f29fb706d3c">npoles_low</a> () const</td></tr>
<tr class="separator:a2b528a200c2b56f9420a5f29fb706d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094f40b3c1d1ff857f696f19d0f85026"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a094f40b3c1d1ff857f696f19d0f85026">npoles_high</a> () const</td></tr>
<tr class="separator:a094f40b3c1d1ff857f696f19d0f85026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb651e7aa0adb9f27cb32fbf14afeb29"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#acb651e7aa0adb9f27cb32fbf14afeb29">current_dt</a> () const</td></tr>
<tr class="separator:acb651e7aa0adb9f27cb32fbf14afeb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446ac405d71fddd4adbd9d2a9722e331"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a446ac405d71fddd4adbd9d2a9722e331">filter_type</a> () const</td></tr>
<tr class="separator:a446ac405d71fddd4adbd9d2a9722e331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9014cb292cb1c7ca452c80c5cb330b43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html#a9014cb292cb1c7ca452c80c5cb330b43">is_zerophase</a> () const</td></tr>
<tr class="separator:a9014cb292cb1c7ca452c80c5cb330b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>MsPASS implementation of <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html" title="MsPASS implementation of Butterworth filter as processing object.">Butterworth</a> filter as processing object. </p>
<p>MsPASS has an existing filter routine that can implement buterworth filters via obspy. This class was created to allow a clean interface to <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html" title="MsPASS implementation of Butterworth filter as processing object.">Butterworth</a> filtering from C++ code that needs such an operator. The original use was an experimental deconvolution code, but there will likely be others because simple, efficient filters are a common internal need for potential applications.</p>
<p>This C++ class can be viewed as a wrapper for Seismic Unix functions that implement <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html" title="MsPASS implementation of Butterworth filter as processing object.">Butterworth</a> filters. The parent functions were found in the cwp lib and were called bfdesign, bfhighpass, and bflowpass. Those three functions are the central tools used to implement this class. All the rest is really just a wrapper to provide an object oriented api to the su functions.</p>
<p>This class implements a processing object concept. That is, it is intended to be constructed and then used for processing multiple data objects with fixed parameters. For Butterwoth filtering the parameters are relatively simple (mainly two corner frequencies and number of poles defining the filter rolloff). A complexity, however, is that the class was designed to allow automatic handling of multiple sample rate data. That is handled internally by caching the sample interval of the data and automatically adjusting the coefficients when the sample interval changes. Note that feature only works for MsPASS data objects CoreTimeSeries and Seismogram where the sample interval is embedded in the object. The raw interface with a simple vector cannot know that. The method to change the expected sample interval has some sanity checks to reduce, but not eliminate the possibility of mistakes that will create unstable filters. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a89009fa487f8a4090c5bce0c4af662cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89009fa487f8a4090c5bce0c4af662cb">&#9670;&nbsp;</a></span>Butterworth() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::Butterworth::Butterworth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>The default constructor does not define a null. The default generates an antialiasing filter identical to the default in the antialias function in seismic unix. That is it produces a low pass filter with a band edge (pass parameter) at 60% of Nyquist and a stop edge at Nyquist. It then calls the su bfdesign function to compute the number of poles and the 3db frequency of the corner to define this filter. These can be retrieved with getters (see below) </p>

</div>
</div>
<a id="afb02193564836b8f7396a9acab24a50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb02193564836b8f7396a9acab24a50e">&#9670;&nbsp;</a></span>Butterworth() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::Butterworth::Butterworth </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>zerophase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>fstoplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>astoplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>fpasslo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>apasslo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>fpasshi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>apasshi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>fstophi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>astophi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sample_interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fully parameterized constructor with args similar to subfilt. </p>
<p>A butterworth filter can be described two ways: (1) corner frequency and number of poles and (2) by band stop and band frequencies. This constructor is used to define the filter by stop and pass band parameters. Frequencies must satisfy fstoplo&lt;fpasslo and fpasshi&lt;fstophi as the four frequencis define a bandd pass between the fpasslo and fpasshi. The stop frequencies define where the response should near zero. Thus for band pass filters the apasslo and apasshi should be 1 and the stop Amplitudes a small number like 0.01. For a band reject filter set stop amplitudes to 1 and pass amplitudes to small numbers like 0.01. (For a reject filter the pass frequencies act like stop frequencies for a bandbpass filer - this is mostly like the subfilt seismic unix program). The booleans control which terms are enabld. When enable_lo is true the lo components are used an when enable_hi is true the high componens are used.</p>
<p>There is a confusing nomenclature related to "high" and "low". In this implmentation I always take low to mean the low side of the passband and high to be the high side of the passband as described above for the 4 frequency point defiitions. The issue is "lowcut" versus "lowpass". Seismic Unix really mixes this up as their implmenetation (which I used here) refernces bflowpass and bfhighpass but subfilt uses the inverse lowcut and higcut terminology. A geeky implementation detail is I actually changed the names of the functions to eliminate the confusion in the implementation. That matters only if you want to compare what we did here to the original seismic unix code.</p>
<p>Note the iir filter coefficiets are always derived from the poles and Frequencies so this constructor is just an alternate way to define the filter without the abstraction of number of poles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zerophase</td><td>when true use a zerophase filter. When false defines a one pass minimum phase filter. </td></tr>
    <tr><td class="paramname">enable_lo</td><td>is a boolean that when true enables the low band parameters for the filter (i.e. the highpass=low-cut components) </td></tr>
    <tr><td class="paramname">enable_hi</td><td>is a boolean taht when true enables the parameters defining the upper frequency band edge (i.e. lowpass=high-cut parameters) </td></tr>
    <tr><td class="paramname">fstoplo</td><td>- stop band frequency for lower band edge </td></tr>
    <tr><td class="paramname">astoplo</td><td>- amplitude at stop frequency (small number for band pass, 1 for band reject) </td></tr>
    <tr><td class="paramname">fpasslo</td><td>- pass band frequency for lower band edge </td></tr>
    <tr><td class="paramname">apasslo</td><td>- amplitude at fpasslo frequency (1 for bandpass, small number for band reject) </td></tr>
    <tr><td class="paramname">fstophi</td><td>- stop band frequency for upper band edge </td></tr>
    <tr><td class="paramname">astophi</td><td>- amplitude at stop frequency (small number for band pass, 1 for band reject) </td></tr>
    <tr><td class="paramname">fpasshi</td><td>- pass band frequency for upper band edge </td></tr>
    <tr><td class="paramname">apasshi</td><td>- amplitude at fpasshi frequency (1 for bandpass, small number for band reject) </td></tr>
    <tr><td class="paramname">sample_interval</td><td>is the expected data sample interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc7717b15d0d13067e819bfe3a81d806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7717b15d0d13067e819bfe3a81d806">&#9670;&nbsp;</a></span>Butterworth() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::Butterworth::Butterworth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1utility_1_1_metadata.html">mspass::utility::Metadata</a> &amp;&#160;</td>
          <td class="paramname"><em>md</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct using tagged valus created from a Metadata container.</p>
<p>This behaves exactly like the fully parameterized contructor except it gets the parameters from metadata. Metadata keys in initial implementation are identical to the argument names defined above. The best guidance for using this constuctor is to look a the comments in the default parameter file.</p>
<p>Construct using tagged valus created from a Metadata container </p>

</div>
</div>
<a id="a85ccda5e0946fd375c03458a90f65c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ccda5e0946fd375c03458a90f65c25">&#9670;&nbsp;</a></span>Butterworth() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::Butterworth::Butterworth </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>zerophase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>npolelo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>f3dblo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>npolehi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>f3dbhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sample_interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct by defining corner frequencies and number of npoles. </p>
<p><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html" title="MsPASS implementation of Butterworth filter as processing object.">Butterworth</a> filters can also be defind by a corner frequency and number of poles. In fact, only the nondimensional form of these parameters are stored as private attributes to define the filter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zerophase</td><td>when true use a zerophase filter. When false defines a one pass minimum phase filter. </td></tr>
    <tr><td class="paramname">enable_lo</td><td>is a boolean that when true enables the low band parameters for the filter (i.e. the highpass=low-cut components) </td></tr>
    <tr><td class="paramname">enable_hi</td><td>is a boolean taht when true enables the parameters defining the upper frequency band edge (i.e. lowpass=high-cut parameters) </td></tr>
    <tr><td class="paramname">npolelo</td><td>is the number of poles for the low frequency corner (highpass) </td></tr>
    <tr><td class="paramname">f3dblo</td><td>is the corner frequency for the low frequency corner (highpass) </td></tr>
    <tr><td class="paramname">npolehi</td><td>is the number of poles for the high frequency corner (lowpass) </td></tr>
    <tr><td class="paramname">f3dbhi</td><td>is the corner frequency for the high frequency corner (lowpass) </td></tr>
    <tr><td class="paramname">sample_interval</td><td>is the expected data sample interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60c3979ede1947661bb25d118bde228c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c3979ede1947661bb25d118bde228c">&#9670;&nbsp;</a></span>Butterworth() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mspass::algorithms::Butterworth::Butterworth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html">Butterworth</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard copy conststructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a76dc3f128a5305ca1b04d863ae72b73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76dc3f128a5305ca1b04d863ae72b73b">&#9670;&nbsp;</a></span>apply() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::algorithms::Butterworth::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmspass_1_1seismic_1_1_core_seismogram.html">mspass::seismic::CoreSeismogram</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the filter to a CoreSeismogram object. </p>
<p>This method alters the data vector inside d in place and changes no other parts of the data. Automatic switching of data sample rate is used on the operator. That is, if the sample rate of the data is different than the operator sample rate the internal operator coefficients will be adjusted to the new sample rate. The operator sample rate will also be changed to the sample rate of d whenever the sample rate changes from the previous call.</p>
<p>This method has a safety to prevent irrational sample rate changes. The IRR filter used to compute a <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html" title="MsPASS implementation of Butterworth filter as processing object.">Butterworth</a> filter becomes unstable if the low pass filter component (high corner) approach Nyquist or worse exceed Nyquist. This method will throw a MsPASSError exception if the sample rate of d is too low for the filter high corner. (current 90% of Nyquist). When this error is throw the data will be unaltered and the internal sample rate will be left in the previous state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>input data to be filtered - altered in place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>a MsPASSError if the hi corner is inconsistent with the sample rate of d </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8c696b150ed18bfb3c4060dd884bfe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c696b150ed18bfb3c4060dd884bfe3">&#9670;&nbsp;</a></span>apply() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::algorithms::Butterworth::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">mspass::seismic::CoreTimeSeries</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pply the filter to a CoreTimeSeries object. </p>
<p>This method alters the data vector inside d in place and changes no other parts of the data. Automatic switching of data sample rate is used on the operator. That is, if the sample rate of the data is different than the operator sample rate the internal operator coefficients will be adjusted to the new sample rate. The operator sample rate will also be changed to the sample rate of d whenever the sample rate changes from the previous call.</p>
<p>This method has a safety to prevent irrational sample rate changes. The IRR filter used to compute a <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html" title="MsPASS implementation of Butterworth filter as processing object.">Butterworth</a> filter becomes unstable if the low pass filter component (high corner) approach Nyquist or worse exceed Nyquist. This method will throw a MsPASSError exception if the sample rate of d is too low for the filter high corner. (current 90% of Nyquist). When this error is throw the data will be unaltered and the internal sample rate will be left in the previous state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>input data to be filtered - altered in place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">throws</td><td>a MsPASSError if the hi corner is inconsistent with the sample rate of d </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb8d56355bb2b23cbf7e96b0b2fa7b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8d56355bb2b23cbf7e96b0b2fa7b24">&#9670;&nbsp;</a></span>apply() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::algorithms::Butterworth::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmspass_1_1seismic_1_1_seismogram.html">mspass::seismic::Seismogram</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the filter to a CoreTimeSeries object. </p>
<p>This method alters the data vector inside d in place and changes no other parts of the data. Automatic switching of data sample rate is used on the operator. That is, if the sample rate of the data is different than the operator sample rate the internal operator coefficients will be adjusted to the new sample rate. The operator sample rate will also be changed to the sample rate of d whenever the sample rate changes from the previous call.</p>
<p>This method has a safety to prevent irrational sample rate changes. The IRR filter used to compute a <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html" title="MsPASS implementation of Butterworth filter as processing object.">Butterworth</a> filter becomes unstable if the low pass filter component (high corner) approach Nyquist or worse exceed Nyquist. This method will automatically disable the high corner (lowpass) component of the filter if the corner approaches or exceed Nyquist. When that happens the internal sample rate is restored to the previous value and a complaint message is posted to elog of d.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>input data to be filtered - altered in place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none,but</td><td>callers should consider checking for errors posted to elog </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10c30a560e4dce8a3bc9fe80409cee80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c30a560e4dce8a3bc9fe80409cee80">&#9670;&nbsp;</a></span>apply() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::algorithms::Butterworth::apply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmspass_1_1seismic_1_1_time_series.html">mspass::seismic::TimeSeries</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the filter to a CoreTimeSeries object. </p>
<p>This method alters the data vector inside d in place and changes no other parts of the data. Automatic switching of data sample rate is used on the operator. That is, if the sample rate of the data is different than the operator sample rate the internal operator coefficients will be adjusted to the new sample rate. The operator sample rate will also be changed to the sample rate of d whenever the sample rate changes from the previous call.</p>
<p>This method has a safety to prevent irrational sample rate changes. The IRR filter used to compute a <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html" title="MsPASS implementation of Butterworth filter as processing object.">Butterworth</a> filter becomes unstable if the low pass filter component (high corner) approach Nyquist or worse exceed Nyquist. This method will automatically disable the high corner (lowpass) component of the filter if the corner approaches or exceed Nyquist. When that happens the internal sample rate is restored to the previous value and a complaint message is posted to elog of d.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>input data to be filtered - altered in place. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none,but</td><td>callers should consider checking for errors posted to elog </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b2416893b09cf7edad320a37c521c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2416893b09cf7edad320a37c521c5a">&#9670;&nbsp;</a></span>apply() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::algorithms::Butterworth::apply </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a raw vector of data. </p>
<p>Use this method to apply the filter to a raw vector of data. The C++ interface uses an std::vector container, but the python api in MsPASS allows this to be a double numpy array or any iterable version of a vector container (meaning storage as a contiguous block of memory). If this method is used it is assumed the sample interval defined for the operator is the same as the for the input data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>is the data to be filtered (note the data are altered in place) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94f20884465265de735d05946e1cea00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f20884465265de735d05946e1cea00">&#9670;&nbsp;</a></span>change_dt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mspass::algorithms::Butterworth::change_dt </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dtnew</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the sample interval assumed for input data. </p>
<p>This function can be used when running with raw data vectors if the sample interval of the data series is different from that called on construction or set previously. This is a nontrivial change because the filter coefficients depend upon sample interval. In particular, for this implementation npoles and the 3db frequency points stored internally are altered when this function is called. If the frequency intervals change the expectation is the user will create a new instance of this object.</p>
<p>Warning: this routine does not implement the safeties built into TimeSeries and Seismogram apply methods. It will silently change the upper corner to an unstable position if called inappropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtnew</td><td>is the new sample interval to set for the operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb651e7aa0adb9f27cb32fbf14afeb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb651e7aa0adb9f27cb32fbf14afeb29">&#9670;&nbsp;</a></span>current_dt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mspass::algorithms::Butterworth::current_dt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the current operator sample interval. </p>

</div>
</div>
<a id="a446ac405d71fddd4adbd9d2a9722e331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446ac405d71fddd4adbd9d2a9722e331">&#9670;&nbsp;</a></span>filter_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mspass::algorithms::Butterworth::filter_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a string defining the type of operator this filter defines. Currently can be one of the following: bandpass, lowpass, or highpass. It is possible to construct a band reject filter with the right constructor, but the implementation of this method will not detect that condition. A band reject filter will be incorrectly tagged bandpass. The algorithm just looks to see which of the band edges are defined (the hi and lo concepts described above) and guesses the filter type. If both are off it returns "Undefined". </p>

</div>
</div>
<a id="acae23f17a07efa21effb10a9da730f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae23f17a07efa21effb10a9da730f33">&#9670;&nbsp;</a></span>high_corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mspass::algorithms::Butterworth::high_corner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the high frequency 3db corner (in Hz). </p>

</div>
</div>
<a id="a7b54d5d5966a85092d45ebebd0b88498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b54d5d5966a85092d45ebebd0b88498">&#9670;&nbsp;</a></span>impulse_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1seismic_1_1_core_time_series.html">CoreTimeSeries</a> mspass::algorithms::Butterworth::impulse_response </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the impulse response. </p>
<p>The response of a linear filter like the butterworth filter can always be described by either the time domain impulse response or its fourier transform commonly called the tranfer function. This function returns the impulse response centered in a time window with a specified number of samples using the current sample interval cached in the object. Note the return has dt and the impulse is at the center of the data window (n/2) with t0 set so the functions zero is correct if using the implict time scale (time method) of a time series object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the number of samples to generate to characterize the impulse response. The function is always returned centered on the vector of length n and t0 of the TimeSeries is set to make that impulse point be time 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9014cb292cb1c7ca452c80c5cb330b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9014cb292cb1c7ca452c80c5cb330b43">&#9670;&nbsp;</a></span>is_zerophase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mspass::algorithms::Butterworth::is_zerophase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the filter is defined as a zero phase filter. Returns false if it is minimum phase. </p>

</div>
</div>
<a id="a98d5b940b443524dbe317ae6b0efb1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d5b940b443524dbe317ae6b0efb1a3">&#9670;&nbsp;</a></span>low_corner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mspass::algorithms::Butterworth::low_corner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the low frequency 3db corner (in Hz). </p>

</div>
</div>
<a id="a094f40b3c1d1ff857f696f19d0f85026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094f40b3c1d1ff857f696f19d0f85026">&#9670;&nbsp;</a></span>npoles_high()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::algorithms::Butterworth::npoles_high </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of poles defining the lowpass (highcut) element of the filter. </p>

</div>
</div>
<a id="a2b528a200c2b56f9420a5f29fb706d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b528a200c2b56f9420a5f29fb706d3c">&#9670;&nbsp;</a></span>npoles_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mspass::algorithms::Butterworth::npoles_low </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of poles defining the highpass (lowcut) element of the filter. </p>

</div>
</div>
<a id="a7602075f3fe8f56e891331c98264d1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7602075f3fe8f56e891331c98264d1a5">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html">Butterworth</a> &amp; mspass::algorithms::Butterworth::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmspass_1_1algorithms_1_1_butterworth.html">Butterworth</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard assignment operator. </p>

</div>
</div>
<a id="a54e766697f72f1ba38b95915805dd6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e766697f72f1ba38b95915805dd6d9">&#9670;&nbsp;</a></span>transfer_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ComplexArray mspass::algorithms::Butterworth::transfer_function </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the response of the filter in the frequency domain. </p>
<p>The impulse response of any linear system can always be characterized by either the time domain response to spike signal or the alternative frequency domain version of the same function commonly called the transfer function. This method returns the transfer funtion as a mspass::algorithms::deconvolution::ComplexArray container. Use methods in that object to get amplitude and phase response functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the number of points that should be used to characterize the transfer function. Note because we are dealing with strictly real valued signals the array returned will be folded at the Nyquist frequency in the standard way of all FFT implementations (current implementation uses the fft in the gnu scientific library that definitely does that). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/mspass/mspass/cxx/include/mspass/algorithms/<a class="el" href="_butterworth_8h_source.html">Butterworth.h</a></li>
<li>/home/runner/work/mspass/mspass/cxx/src/lib/algorithms/Butterworth.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
