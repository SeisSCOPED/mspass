

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Database Concepts &mdash; MsPASS 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Tutorial" href="../tutorial.html" />
    <link rel="prev" title="Data Object Design Concepts" href="data_object_design_concepts.html" />  

  <style>
    .wy-nav-content { max-width: 1600px; }
  </style>

  
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> MsPASS
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../user_manual.html">User’s Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../user_manual.html#overview-primary-features-of-mspass">Overview - Primary Features of MsPASS</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../user_manual.html#design-concepts">Design Concepts</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../user_manual.html#role-of-python-and-c">Role of Python and C++</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="data_object_design_concepts.html">Data Object Design Concepts</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Database Concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="../user_manual.html#crud-operations-in-mspass">CRUD operations in MsPASS</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user_manual.html#parallel-processing">Parallel Processing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference_manual.html">Reference Manual</a></li>
</ul>

            
          
    <a href= "../genindex.html">Index</a>
  
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MsPASS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../user_manual.html">User’s Manual</a> &raquo;</li>
        
      <li>Database Concepts</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/user_manual/database_concepts.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="database-concepts">
<span id="id1"></span><h1>Database Concepts<a class="headerlink" href="#database-concepts" title="Permalink to this headline">¶</a></h1>
<div class="section" id="nonsql-database">
<h2>NonSQL Database<a class="headerlink" href="#nonsql-database" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">MsPASS uses a NonSQL database called MongoDB.   NonSQL is a generic
name today for a database system that does not utilize the structure
query language (SQL).  SQL is the standard language for interacting
with relational database systems like Oracle, MySQL, PostGRES, etc.
One type of NonSQL database is a “document database”.  MongoDB is
classified as a document database.   Readers unfamiliar with the
concept of a document database are referred to online sources which
are far better than anything we could produce.   A good starting point
is the <a class="reference external" href="https://docs.mongodb.com/manual/introduction/">MongoDB tutorial
introduction</a>.
Another good source is <a class="reference external" href="https://www.tutorialspoint.com/mongodb/index.htm">this
one</a> on
tutorialspoint.</div>
</div>
</div>
<div class="section" id="schema">
<h2>Schema<a class="headerlink" href="#schema" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>Wikepedia defines a database schema as follow:</p>
<div class="line-block">
<div class="line">The term “<a class="reference external" href="https://en.wiktionary.org/wiki/schema">schema</a>”
refers to the organization of data as a blueprint of how the database
is constructed (divided into database tables in the case of <a class="reference external" href="https://en.wikipedia.org/wiki/Relational_databases">relational
databases</a>)
the schema defines a set of attributes, tables (relations), and how
they can be linked (joined).</div>
</div>
<p>As this definition states in a relational database like CSS3.0 the
schema defines a set of attributes, tables (relations) and a how they are
linked (joined).   MsPASS uses a “nonSQL database”, which means the interaction
is not with Structured Query Language (SQL).   We use a particular
form of nonSQL database called a “document database” as implemented in
the open source package <a class="reference external" href="https://www.mongodb.com/">MongoDB</a>.
The top-level concept for understanding what MongoDB is name-value pairs.
One way of thinking of MongoDB is that it only implements each attribute
as a name-value pair:  the name is the key that defines the concept and
the attribute is the thing that defines that concept.  The thing can
be something as simple as an integer number or as elaborate as any python
object.  Table (relations) are replaced with that concept of a “document”
that is conceptually similar but operationally very different.
A document is a collection of name-value pairs that is conceptually
similar to a single tuple in a table (relation).</p>
</div>
<div class="section" id="design-concepts">
<h3>Design Concepts<a class="headerlink" href="#design-concepts" title="Permalink to this headline">¶</a></h3>
<p>A properly designed database schema needs to prioritize the problem it
aims to solve.   The schema for MsPASS was aimed to address the
following design goals:</p>
<ol class="arabic simple">
<li><p><em>Efficient flow through Spark.</em> A key reason MongoDB was chosen as
the database engine for MsPASS was that it is cleanly integrated with
Spark.   Nonetheless, the design needs to minimize database
transaction within a workflow.   Our aim was to try to limit database
transaction to reading input data, saving intermediate results, and
saving a final result.</p></li>
<li><p><em>KISS (Keep It Simple Stupid).</em> Experience has shown clearly that
complex relational schemas like CSS3.0 have many, sometimes subtle,
issues that confound beginners.  A case in point is that large
organizations commonly have a team of database managers to maintain
the integrity of their database and optimize performance.   An
important objective of our design is to keep it simple so scientists
do not have to become database managers to work with the system.</p></li>
<li><p><em>Efficient and robust handling of three-component seismograms.</em>
Although MsPASS supports <a class="reference internal" href="data_object_design_concepts.html#data-object-design-concepts"><span class="std std-ref">scalar seismic
data,</span></a> our view is that the
greater need in the community is an efficient system for handling 3C
data.   In reality, our schema design ended up completely neutral on
this point and scalar and 3C data are handled identically.  The only
differences is what attributes (Metadata) are required.</p></li>
<li><p><em>Provide a clean mechanism to manage static metadata.</em> MsPASS is a
system designed to process a “data set”, which means the data are
preassembled, validated, and then passed into a processing chain.
The first two steps (assembly and validation) are standalone tasks
that require assembly of waveform data and a heterogenous collection
of metadata from a range of sources.   Much of that problem has been
the focus of extensive development work by IRIS and the FDSN.   We
thus provide tools for importing datasets through web services that
have become the current, standard exchange for data and Metadata.
The complexity of the Metadata is the reason that development effort
has been far from trivial.   A primary issue is that some attributes
change with nearly every seismogram (e.g. the start time of a
waveform), while many others either never change (e.g. a station name
almost never changes) or change rarely (e.g. a change in sensor
orientation).  We aimed for a balance to efficiently manage static
data while avoiding all the things that can go wrong that have to be
handled by network operators and the PIs of shorter term
deployments.</p></li>
<li><p><em>Extensible.</em> A DBMS cannot be too rigid, or it will create
barriers to progress.  This is especially important to MsPASS as our
objective is to produce a system for seismic research, not a
production system for repetitive processing of the similar data.
(Seismic reflection processing and seismic network catalog
preparation are two examples of repetitive processing in
seismology.)  A goals was to provide a mechanism for users to extend
the database with little to no impact on the core system.</p></li>
</ol>
<div class="line-block">
<div class="line">On the other hand, we have explicitly avoided worrying about problems
we concluded were already solved.  These are:</div>
</div>
<ol class="arabic simple">
<li><p><em>Catalog preparation.</em>   At this time a primary job of most
operational seismic networks of all scales is preparation of a
catalog of seismic events and linking that information to data used
to generate the event location and source parameters.  There are
multiple commercial and government supported systems for solving
this problem.   We thus treat catalog data as an import problem.</p></li>
<li><p><em>Real time processing</em>.   Although there are elements of MsPASS that
are amenable to near real time processing of streaming data, we view
real time processing as another solved problem outside the scope of
this system.</p></li>
</ol>
</div>
<div class="section" id="collections">
<h3>Collections<a class="headerlink" href="#collections" title="Permalink to this headline">¶</a></h3>
<p><em>Overview</em>.  In MongoDB a <em>collection</em> is roughly equivalent to a table (relation)
in a relational database.  Each collection holds one or more <em>documents</em>.
A single document is roughly equivalent to a tuple in a relational database.
In this section we describe how we group documents into collections defined
in MsPASS.   These collections and the attributes they contain are the
<em>schema</em> for MsPASS.</p>
<p><em>wf</em>.  The wf collection is THE core table in
MsPASS.  All seismogram read operations access ONLY the wf collection.
Writers are more complicated because they may have to deal with
newly generated attributes and potentially fundamental changes in the
nature of the waveform we want to index.  <em>e.g.</em>, a stack can become
completely inconsistent with the concept of a station name and may
require creation of a different set of attributes like an index back to
the parent seismograms that created the stack.   We thus define this
rule that all users need to recognize in designing a MsPASS workflow:</p>
<div class="line-block">
<div class="line"><strong>Rule 1</strong>.  All required attributes to run a workflow must exist in the
wf collection before starting the job.</div>
</div>
<div class="line-block">
<div class="line">An abstract way of saying this is that at the start of processing the
input data must obey what MongoDB calls an
<a class="reference external" href="https://docs.mongodb.com/manual/core/data-model-design/">embedded</a>
data model.  To many seismologists a less abstract way of saying this is
that the database contents must define all required header attributes
needed for the processing. On the other hand, the full system has support for
<em>normalized</em> data managed by collections like site and source (see
below - note the list of normalization collections is expected to
evolve as MsPASS is developed).</div>
</div>
<div class="line-block">
<div class="line">This model was chosen exactly due to design issues 1 and 2 above:
data processing is efficient because database transactions are limited
to the initial loading of data into the system, and the model
satisfies the KISS principle because within a processing chain
attributes look like header data accessible by simple name:value pair
getters and putters.</div>
</div>
<div class="line-block">
<div class="line">Users must also realize that the sample data in Seismogram or TimeSeries objects
be constructed from <em>wf</em> documents in one of two ways.  First, the sample data
can be stored in the more conventional method of CSS3.0 based systems
as external files.   In this case, we use the same construct as CSS3.0 where
the correct information is defined by three attribures:  <em>dir</em>, <em>dfile</em>, and
<em>foff</em>.   Unlike CSS3.0 MsPASS currently requires external file data to be
stored as native 64 bit floating point numbers.   We force that restriction
for efficiency as the Seismogram <em>u</em> variable and the TimeSeries <em>s</em>
variable can then be read and written with fread and fwrite respectively from
the raw buffers.  The alternative (second) method for storing sample data
in MsPASS is through a mechanism called <em>gridfs</em> in MongoDB.  When this
method is used (it is the default) the waveform sample data are managed
by file system like handles inside MongoDB.  That process is largely hidden
from the user, but the most important thing the user must recognize is
that when this method is used the sample data are stored in the same
disk area where MongoDB stores it’s other data.  Details about the
interaction this method requires with the gridfs_wf collection are given below.</div>
</div>
<div class="line-block">
<div class="line"><em>gridfs_wf</em>.  This collection is best thought of as an auxiliary
collection that comes into play when the (default) <em>gridfs</em> approach
is used to store waveform sample data.  Each document in <em>gridfs_wf</em>
has a one-to-one relation with a related document in <em>wf</em>.  The
entry in <em>wf</em> is treated as the master since all processing in MsPASS is
driven by the <em>wf</em> collection.   The gridfs attributes needed to load
waveform data stored through <em>gridfs_wf</em> are linked to <em>wf</em> through
a MongoDB object id.  Specifically, <em>wf</em> documents with data stored in
gridfs use the attribute name <em>gridfs_wf_id</em> to hold the ObjectID of the
document in <em>gridfs_wf</em> that defines the waveform data.  Readers
thus need to either join gridfs_wf and wf with the gridfs_wf_id key or
run a large number find transactions to connect the proper wf and gridfs_wf
documents.</div>
</div>
<div class="line-block">
<div class="line"><em>elog</em>.   The elog collection holds log messages that should
automatically be posted and saved in a MsPASS workflow.  The elog
collection saves any entries in ErrorLogger objects that are
components of all data objects handled internally by MsPASS.   The
main idea of an ErrorLogger is a mechanism to post errors of any level
of severity to the data with which the error is associated, preserve a
record that can be used by the user to debug the problem, and allow
the entire job to run to completion even if the error made the data
invalid.  More details about this idea can be found in the <a class="reference internal" href="data_object_design_concepts.html#data-object-design-concepts"><span class="std std-ref">Data
Objects</span></a> section.</div>
</div>
<div class="line-block">
<div class="line"><em>site</em>. The site collection is intended as a largely static table
that can be used to
<a class="reference external" href="https://docs.mongodb.com/manual/core/data-model-design/">normalize</a>
a wf collection.   The name is (intentionally) identical to the CSS3.0
site table.   It’s role is similar, but not identical to the CSS3.0
table.  There are two primary differences.  First, the (unnecessary in
our view) requirement of a station name tag is not required in the
documents the collection contains.  It is optional.  Second, the link
to data is not defined through a station name tag, but by a form of
spatial query.  The use of a spatial query was a design decision based
on the author’s experiences using CSS3.0’s site table as implemented
in Antelope.   Antelope uses the station name and a time period as a
key to find location information for a waveform.   That model works
well for bulletin preparation but creates a dilemma for processed
waveforms;  the concept of a “station name” is meaningless for many
types of processed waveform.  Two type examples, are a phased array
beam and Common Conversion Point (CCP) stacks of receiver functions.
On the other hand, many such processed waveforms have a space concept
that needs to be preserved.  Hence, the location information in the
collection may relate to some more abstract point like  piercing point
for a CCP stack.   Each document is keyed with a unique integer with
tag (siteid) as well as the ObjectId that is automatically generated
(and required) by MongoDb.   wf documents can index a location in site
either through the siteid, or the ObjectId of an entry in the
collection (the choice is implementation dependent).</div>
</div>
<div class="line-block">
<div class="line">A spatial query to link anything to a point in the site collection has
two complexities:  (1) all spatial queries require a uncertainty
specification that are data and implementation dependent, and (2)
sometimes, but not always, a vertical position (site_elev) needs to be
defined.  The first is readily solved with the geospatial indexing
capabilities of MongoDB.   Geospatial queries can define a radius of
uncertainty to efficiently find one or more documents linked to a
circle defined relative to a query point.  The size of such a circle
is always a data dependent choice;  a scientist working with free
oscillations of the earth require station coordinates with minimal
precision, while an active source experiment often requires submeter
location precision.   We treat vertical positions differently.  The
common key to define vertical position is <em>site_elev</em>.   How to handle
vertical position is application dependent.  <em>e.g.</em> to look up the
location of an operational GSN station, it may be necessary to
distinguish borehole and vault instruments that are deployed at many
stations.   In contrast, a point defined by piercing points for a CCP
stack would normally be assumed referenced to a common, fixed depth so
site_elev may not even be needed.  We deal with this complexity by a
defining another rule that user’s need to recognize and abide by:</div>
</div>
<div class="line-block">
<div class="line"><strong>Rule 2</strong>. The site collection only contains points in space relevant to
the data set.   Assembly of a working data set requires linking
required points in site to wf documents as required and defining the
coordinates with the proper wf keys.</div>
</div>
<div class="line-block">
<div class="line">As an example, to begin processing on a set of raw waveforms imported
from the FDSN the wf collection would normally need to be normalized
with data from site to set geographic locations of the instrument that
generated each wf entry:  <em>site_lat, site_lon,</em> and <em>site_elev</em>.
Partially processed wf entries may require the definition of
additional geospatial points in site.</div>
</div>
<div class="line-block">
<div class="line">Managing response information for seismic instruments is a related problem.
We handle it through site, but recognize that response information has
issues similar to that discussed above for the simpler concept of a
station name.  That is, response data is not always required or even
necessary for the workflow (e.g. in reflection processing most algorithms
assume all data have a common instrument response and algorithm only cares
that they are matched.).  We treat response data as a raw waveform attribute
that can optionally be utilized by obspy tools.  The site collection
can contain an optional pickled version of the obspy Inventory object
that can be used by algorithms to implement response corrections.</div>
</div>
<div class="line-block">
<div class="line"><em>source</em>. The source collection has much in common with site, but
has two fundamental differences:  (1) the origin time of each source
needs to be specified, and (2) multiple estimates are frequently
available for the same source.</div>
</div>
<div class="line-block">
<div class="line">The origin time issue is a more multifaceted problem that it might
first appear.  The first is that MongoDB, like ArcGIS, is map-centric
and stock geospatial queries lack a depth attribute, let alone a time
variable.   Hence, associating a waveform to a source position defined
in terms of hypocenter coordinates (<em>source_lat, source_lon,
source_depth</em>, and <em>source_time</em>) requires a multistage query that can
potentially be very slow for a large data set.   Hence, Rule 2 could
be restated as Rule 3 with “site collection” replaced everythere by
“source collection”.</div>
</div>
<div class="line-block">
<div class="line">The other issue that distinguishes origin time is that it’s accuracy
is data dependent.   With earthquake it is always estimated by an
earthquake location algorithm, while with active source it normally
measured directly.  The complexity with active source data is a
classic case distinguishing “precision” from “accuracy”.   Active
source times relative to the start time of a seismogram may be very
precise but not accurate.  A type example is multichannel data where
time 0 of each seismogram is defined by the shot time, but the
absolute time linked to that shot may be poorly constrained.   We
address this problem in MsPASS through the concept of UTC versus
“Relative” time definined in all MsPASS data objects.  See the <a class="reference internal" href="data_object_design_concepts.html#data-object-design-concepts"><span class="std std-ref">Data
Object section</span></a> on BasicTimeSeries
for more on this topic.</div>
</div>
<div class="line-block">
<div class="line">A final point about the source table is the issue of multiple
estimates of the same event.   The CSS3.0 has an elaborate mechanism
for dealing with this issue involving three closely related tables
(relations):  event, origin, assoc, and arrival.   The approach we
take in MsPASS is to treat that issue as somebody else’s problem.
Thus, for the same reason as above we state rule 3 which is very
similar to rule 2:</div>
</div>
<div class="line-block">
<div class="line"><strong>Rule 3</strong>.  The source collection should contain any useful source
positions that define locations in space and time (attributes
<em>source_lat, source_lon, source_depth</em>, and <em>source_time</em>).  Linking
each document in a wf collection to the desired point in the source
collection is a preprocessing step to define a valid dataset.</div>
</div>
<div class="line-block">
<div class="line">The consequences to the user is that associating each document in <em>wf</em> with
the correct source information must be understood as a processing step.
Once a MsPASS workflow is initiated it can and should assume the source
information loaded is the best available.   We also emphasize that for
efficiency preprocessing needs to load source coordinates (or any other
required source information like uncertainties) as attributes in the
<em>wf</em> collection copied from <em>site</em>.  That is required because algorithms
in a MsPASS workflow can and should always avoid database transactions
within the workflow other than saving intermediate or final results to
the <em>wf</em> collection.</div>
</div>
<div class="line-block">
<div class="line"><em>history</em>. | An important requirement to create a reproducible result from
data is a mechanism to create a full history that can be used to recreate
a workflow.  The same mechanism provides a way for you to know the sequence
of processing algorithms that have been applied with what tunable parameters
to produce results stored in the database.  The history collection stores this
information.   Most users should never need to interact directly with this
collection so we omit any details of the history collection contents from
this manual.  Users should, however, understand the concepts described
in - link to new document in this manual on ProcessingHistory concepts –</div>
</div>
<div class="line-block">
<div class="line"><em>global</em>.  Not yet implemented, but something we need.  Should be a
place to hold global attributes.  Examples might be unit definitions,
space tolerance for site information, space-time tolerance for events,
and an alternative to yaml storage of data stored now in mspass.yaml.</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../tutorial.html" class="btn btn-neutral float-right" title="Tutorial" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="data_object_design_concepts.html" class="btn btn-neutral float-left" title="Data Object Design Concepts" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Ian Wang

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>